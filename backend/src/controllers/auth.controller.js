import User from "../models/user.model.js";
import bcrypt from "bcryptjs";
import { generateToken } from "../lib/utils.js";
import cloudinary from "../lib/cloudinary.js";

export const signup = async (req, res) => {
  const { fullName, email, password } = req.body;
  try {
    if (!fullName || !email || !password) {
      return res.status(400).json({ message: "All fields required" });
    }
    if (password.length < 8) {
      return res
        .status(400)
        .json({ message: "Password should be minimum 8 characters" });
    }
    // create user
    const user = await User.findOne({ email });
    if (user) {
      return res
        .status(400)
        .json({ message: "Account with this email already exists." });
    }

    // now we have verified that no user exists with the given email and password length is valid
    // we can go ahead and hash the password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);

    const newUser = new User({
      fullName,
      email,
      password: hashedPassword,
    });
    if (newUser) {
      // we will make use of the _id field here generated by default by mongoDB
      generateToken(newUser._id, res);
      await newUser.save();
      res.status(201).json({
        _id: newUser._id,
        fullName: newUser.fullName,
        email: newUser.email,
        profilePic: newUser.profilePic,
      });
    } else {
      return res.status(400).json({ message: "User not created" });
    }
  } catch (error) {
    console.log("Error in signup controller");
    res.status(500).json({ message: "Internal Server Error" });
  }
};

export const login = async (req, res) => {
  // get user input from the request body
  if (!req.body) {
    return res.status(400).json({ message: "Request body empty" });
  }
  const { email, password } = req.body;
  try {
    // check if this user exists in the database
    const user = await User.findOne({ email });
    // if the user does not exist
    if (!user) {
      return res
        .status(400)
        .json({ message: "Account does not exist. Sign up!" });
    }
    // now matching password
    // one important thing to remember when working with encryption of passwords is that they are always hashed one way...you cannot decrypt the existing psswd in the db and then match...instead what you have to do it you take the user input password and then hash that too using the same key and then simpply compare if the input password is same as the account password

    const isPasswordCorrect = await bcrypt.compare(password, user.password);
    if (!isPasswordCorrect) {
      return res.status(400).json({ message: "Invalid Credentials" });
    }

    // else
    generateToken(user._id, res);

    res.status(200).json({
      _id: user._id,
      fullName: user.fullName,
      email: user.email,
      profilePic: user.profilePic,
    });
  } catch (error) {
    console.log("Error in Login Controller", error.message);
    return res.status(500).json({ message: "Internal Server Error" });
  }
};

export const logout = (req, res) => {
  // while a user tries to logout all we have to do is just end the session and clear the cookies which has the jwt token
  try {
    // set the cookie to null and make it expire immediately
    res.cookie("jwt", "", { maxAge: 0 });
    return res.status(200).json({ message: "Logout Successfull" });
  } catch (error) {
    console.log("Error in Logout Controller");
    return res.status(500).json({ message: "Internal Server Error" });
  }
};

export const updateProfile = async (req, res) => {
  try {
    const { profilePic } = req.body;
    const userId = req.user._id;

    if (!profilePic) {
      return res.status(400).json({ message: "Profile Pic is required" });
    }

    const uploadResponse = await cloudinary.uploader.upload(profilePic);
    // now we can update the profile picture in the database (as cloudinary is not our database...it is just a bucket for our storage)
    const updatedUser = await User.findByIdAndUpdate(
      userId,
      {
        profilePic: uploadResponse.secure_url,
      },
      { new: true }
    );

    res.status(200).json(updatedUser);
  } catch (error) {
    console.log("Error in Update Profile Controller", error.message);
    return res.status(500).json({ message: "Internal Server Error" });
  }
};

export const checkAuth = async (req, res) => {
  try {
    return res.status(200).json(req.user);
  } catch (error) {
    console.log("Error in CheckAuth Controller", error.message);
    return res.status(500).json({ message: "Internal Server Error" });
  }
};
